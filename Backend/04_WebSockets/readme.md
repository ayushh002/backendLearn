> WebSockets enable bidirectional, real-time communication where the server can push data to clients without requiring explicit requests from them.

> WebSockets eliminate the need for frequent polling. Polling (short polling) is the old approach where clients repeatedly ask the server for updates.

> In long polling, the server keeps the client’s request open until it has data to send. This approach holds connections for long periods, consumes server resources, and increases overall load.

> HTTP streaming (keeping an HTTP response open and sending a continuous stream of chunks) allows server → client streamed updates. However, these streams run over TCP, which guarantees in-order delivery — meaning if a packet is lost, TCP will retransmit it and pause all subsequent data until the lost packet is received. This causes visible pauses in the stream under packet loss.

> WebSockets were introduced to provide a full-duplex, low-latency, bidirectional channel between client and server. The WebSocket handshake begins as an HTTP/1.1 Upgrade request over an existing TCP connection (the client sends an HTTP request with Upgrade: websocket). After the handshake, the protocol switches to WebSocket on the same TCP connection, allowing both sides to send messages freely without additional HTTP requests.

> Socket.IO is a library built on top of WebSockets that enables low-latency, bidirectional, event-based communication between a client and a server. It automates many tasks and simplifies operations compared to using raw WebSocket APIs (similar to how Mongoose simplifies working with MongoDB).

> Historically, some browsers or network environments lacked WebSocket support or blocked WebSocket traffic. Libraries like Socket.IO can automatically fall back to HTTP long polling or WebTransport if the browser is incompatible with web sockets. 

> With raw WebSockets, we often need to write additional code to check whether a connection is still alive so that inactive connections can be closed to free resources. Socket.IO automates this using built-in heartbeat pings to verify that the connection is still active.

> Socket.IO also handles retransmitting messages when acknowledgements are not received from the client because of connection issues or packet loss.

> Let’s understand WebSockets through code. For this, we will install Socket.IO along with Express and Nodemon to create a WebSocket server.

> To create the frontend, we will use the Socket.IO client via a script tag in the HTML file that contains the chat UI. We will serve this HTML file from the backend using the path module when the default URL is accessed.

> This way, we don’t need to host the frontend and backend separately — the HTML becomes part of the backend server. However, externally linked CSS files won’t load in this simple setup when served this way, so we embed the CSS inside a style tag in the same HTML file.

> If we open the URL in two different tabs on the same device, the socket IDs will still be different even though the IP is the same, because each tab runs in a separate browser context (different port number) with its own connection.

> Here, we created a normal chat app that anyone can access on the server. To support chatting inside a specific room or group — where only users who join that room can see the messages — we can use Socket.IO rooms. We can achieve this by generating a room ID and sending it to the backend socket, which creates a separate room using socket.join(room_id).

> Now, if we want to send one on one message which can occur between two individuals only, we would need to emit the message particularly between those two clients using their socket ids. This internally implements room which is only created between two individuals.

> But we cannot acheive this functionality simply using socket id as it keeps on changing. So, a practical solution would be using something that does not change at all like phone number, username, user id, etc., along with the socket id which can be stored on the data base like redis which will store the phone_number/username and the socket id as key-value pair and then emit the message by checking the corresponding socket id stored on the redis server for tha phone number/username.

> We have to store all the socket id corresponding a same user in the form of array as the user can open the chat app on multiple tabs which will have different socket ids, so it is necessary that the message is delivered to all those tabs. The socket id is generated by the system using the combination of IP address, port number, etc.
